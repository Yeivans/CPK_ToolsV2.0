<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>Accuracy CPK</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link rel="stylesheet" href="accuracy-cpk-tool.css">
    <link rel="icon" href="favicon.png" type="image/png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
      
</head>
<body>
    <div class="main-full">
      <div class="content-area">
        <!-- 返回主页按钮 - 响应式位置 -->
        <div class="back-home-btn">
            <a href="../index.html" class="btn btn-secondary">
                <i class="fa-solid fa-arrow-left"></i> 返回主頁
            </a>
        </div>

        <!-- 右上角按钮组 -->
        <div class="fixed-right-top">
            <i class="fa-solid fa-circle-question help-icon"
               title="1.點擊選擇資料夾，上傳包含Accuracy測試數據的txt文件
2.點擊'執行 Accuracy CPK'分析數據
3.點擊'導出 CPK Excel'匯出結果"></i>
            <select id="langSelect" class="cpk-btn lang-btn">
                <option value="zh-TW">繁體中文</option>
                <option value="en">English</option>
                <option value="vi">Tiếng Việt</option>
            </select>
            <button id="toggleChatBtn" class="cpk-btn chat-toggle-btn">
                <i class="fa-solid fa-comments"></i> 顯示AI聊天
            </button>
        </div>

        <!-- 控制面板区域 -->
        <div class="control-panel">
            <!-- 标题 -->
            <h1><i class="fa-solid fa-bullseye" style="margin-right: 16px;"></i>Accuracy CPK</h1>
            
            <!-- 工具栏 -->
            <div class="toolbar">
                <div>
                    <button id="chooseFolderBtn" class="btn">
                        <i class="fa-solid fa-folder-open" style="margin-right: 8px;"></i> 選擇資料夾
                    </button>
                    <input type="file" id="folderUpload" webkitdirectory multiple style="display:none;">
                </div>
                <div>
                    <button id="execAccuracyCpkBtn" class="btn btn-success">執行 Accuracy CPK</button>
                </div>
                <div>
                    <button id="exportCpkBtn" class="btn" style="background: #FF9500; display: none;">
                        <i class="fa-solid fa-download" style="margin-right: 8px;"></i>導出 CPK Excel
                    </button>
                </div>
            </div>
            <!-- 文件列表 -->
            <div id="folderFileList"></div>
        </div>

        <!-- 数据显示区域 -->
        <div class="data-panel">
        
        <!-- AI聊天框 -->
        <div id="ai-chat-box">
            <div id="ai-chat-drag">
                <i class="fa-solid fa-robot"></i> AI詢問聊天
            </div>
            <div id="ai-chat-history"></div>
            <div class="ai-chat-input-bar">
                <input id="ai-chat-input" type="text" placeholder="請輸入您的問題...">
                <button id="ai-chat-send" class="btn">
                    <i class="fa-solid fa-paper-plane"></i> 發送
                </button>
            </div>
        </div>
        <script>
        // 翻译内容
        const translations = {
            'zh-TW': {
                title: 'Accuracy CPK',
                uploadFolder: '選擇資料夾',
                executeAccuracyCpk: '執行 Accuracy CPK',
                exportCpkExcel: '導出 CPK Excel',
                showAiChat: '顯示AI聊天',
                hideAiChat: '隱藏AI聊天',
                aiChat: 'AI詢問聊天',
                inputPlaceholder: '請輸入您的問題...',
                send: '發送',
                help: '1.點擊選擇資料夾，上傳包含Accuracy測試數據的txt文件\n2.點擊"執行 Accuracy CPK"分析數據\n3.點擊"導出 CPK Excel"匯出結果'
            },
            'en': {
                title: 'Accuracy CPK',
                uploadFolder: 'Choose Folder',
                executeAccuracyCpk: 'Execute Accuracy CPK',
                exportCpkExcel: 'Export CPK Excel',
                showAiChat: 'Show AI Chat',
                hideAiChat: 'Hide AI Chat',
                aiChat: 'AI Chat',
                inputPlaceholder: 'Enter your question...',
                send: 'Send',
                help: '1. Click to choose folder and upload txt files containing Accuracy test data\n2. Click "Execute Accuracy CPK" to analyze data\n3. Click "Export CPK Excel" to export results'
            },
            'vi': {
                title: 'Accuracy CPK',
                uploadFolder: 'Chọn thư mục',
                executeAccuracyCpk: 'Thực hiện Accuracy CPK',
                exportCpkExcel: 'Xuất CPK Excel',
                showAiChat: 'Hiện AI Chat',
                hideAiChat: 'Ẩn AI Chat',
                aiChat: 'Hỏi đáp AI',
                inputPlaceholder: 'Nhập câu hỏi của bạn...',
                send: 'Gửi',
                help: '1. Nhấp để chọn thư mục và tải lên các tệp txt chứa dữ liệu thử nghiệm Accuracy\n2. Nhấp "Thực hiện Accuracy CPK" để phân tích dữ liệu\n3. Nhấp "Xuất CPK Excel" để xuất kết quả'
            }
        };

        // 选择文件夹按钮和执行Accuracy CPK按钮
        document.addEventListener('DOMContentLoaded', function() {
            var chooseBtn = document.getElementById('chooseFolderBtn');
            var folderInput = document.getElementById('folderUpload');
            var execBtn = document.getElementById('execAccuracyCpkBtn');
            var exportBtn = document.getElementById('exportCpkBtn');
            
            // 检查浏览器是否支持文件夹选择
            if (!folderInput.webkitdirectory === undefined) {
                chooseBtn.innerHTML = '<i class="fa-solid fa-exclamation-triangle" style="margin-right: 8px;"></i> 瀏覽器不支持資料夾選擇';
                chooseBtn.disabled = true;
                alert('❌ 當前瀏覽器不支持資料夾選擇功能，請使用Chrome、Edge或Firefox瀏覽器');
                return;
            }
            
            // 绑定点击事件
            chooseBtn.onclick = function() { 
                console.log('點擊選擇資料夾按鈕');
                try {
                    folderInput.click();
                } catch (error) {
                    console.error('觸發文件選擇出錯:', error);
                    alert('無法打開文件選擇器，請重試或使用其他瀏覽器');
                }
            };
            folderInput.addEventListener('change', function(event) {
                const files = event.target.files;
                const list = document.getElementById('folderFileList');
                list.innerHTML = '';
                if (files.length === 0) {
                    list.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">未選擇任何文件</div>';
                    return;
                }
                // 创建表格展示文件信息
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                const thead = document.createElement('thead');
                const trHead = document.createElement('tr');
                ['名稱', '格式', '大小 (KB)', '相對路徑'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    th.style.border = '1px solid #ccc';
                    th.style.background = '#f5f5f7';
                    th.style.padding = '6px 8px';
                    trHead.appendChild(th);
                });
                thead.appendChild(trHead);
                table.appendChild(thead);
                const tbody = document.createElement('tbody');
                // 默认显示文件列表
                for (const file of files) {
                    const tr = document.createElement('tr');
                    // 名稱
                    const tdName = document.createElement('td');
                    tdName.textContent = file.name;
                    tdName.style.border = '1px solid #ccc';
                    tdName.style.padding = '6px 8px';
                    tr.appendChild(tdName);
                    // 格式
                    const tdType = document.createElement('td');
                    tdType.textContent = file.type || '未知';
                    tdType.style.border = '1px solid #ccc';
                    tdType.style.padding = '6px 8px';
                    tr.appendChild(tdType);
                    // 大小
                    const tdSize = document.createElement('td');
                    tdSize.textContent = (file.size / 1024).toFixed(2);
                    tdSize.style.border = '1px solid #ccc';
                    tdSize.style.padding = '6px 8px';
                    tr.appendChild(tdSize);
                    // 相對路徑
                    const tdPath = document.createElement('td');
                    tdPath.textContent = file.webkitRelativePath || '';
                    tdPath.style.border = '1px solid #ccc';
                    tdPath.style.padding = '6px 8px';
                    tr.appendChild(tdPath);
                    tbody.appendChild(tr);
                }
                table.appendChild(tbody);
                list.appendChild(table);
                // 不再需要鼠标悬停控制，文件列表直接显示
                
                // 在控制台显示上传完成信息
                console.log('✅ 資料夾上傳完成，共', files.length, '個文件');
            });
            // 执行Accuracy CPK按钮事件（预留，实际功能可扩展）
            execBtn.onclick = function() {
                let cpkTableDiv = document.getElementById('accuracyCpkTable');
                if (!cpkTableDiv) {
                    cpkTableDiv = document.createElement('div');
                    cpkTableDiv.id = 'accuracyCpkTable';
                    document.querySelector('.data-panel').appendChild(cpkTableDiv);
                }
                const folderInput = document.getElementById('folderUpload');
                const files = folderInput.files;
                let txtFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.txt'));
                if (txtFiles.length === 0) {
                    cpkTableDiv.innerHTML = '<div>未找到txt文件</div>';
                    return;
                }
                let readCount = 0;
                let snMap = {};
                let modelName = ''; // 添加变量来存储Model Name
                txtFiles.forEach(function(file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const text = e.target.result;
                        let match = text.match(/Serial No\s*[:：]?\s*([\w\-]+)/i);
                        let sn = match && match[1] ? match[1] : '(未识别)';
                        
                        // 提取Model Name
                        if (!modelName) { // 只在第一次找到时设置
                            let modelMatch = text.match(/Model Name\s*[:：]\s*([A-Za-z0-9\-]+)/i);
                            if (modelMatch && modelMatch[1]) {
                                modelName = modelMatch[1].trim();
                            }
                        }
                        
                        let lines = text.split(/\r?\n/);
                        // 记录所有AC Input和Load Setup的内容及行号
                        let acInputs = [];
                        let loadSetups = [];
                        for (let i = 0; i < lines.length; i++) {
                            if (/^STEP\..*: AC Input/.test(lines[i])) {
                                if (lines[i+1] && /^Describe\s*:/.test(lines[i+1])) {
                                    let desc = lines[i+1].replace(/^Describe\s*: /, '').trim();
                                    acInputs.push({idx: i, desc: desc});
                                }
                            }
                            if (/^STEP\..*: Load Setup/.test(lines[i])) {
                                let desc = '';
                                if (lines[i+1] && /^Describe\s*:/.test(lines[i+1])) {
                                    desc = lines[i+1].replace(/^Describe\s*: /, '').trim();
                                }
                                loadSetups.push({idx: i, desc: desc});
                            }
                        }
                        // 查找Accuracy Test块
                        let blockStartIdxs = [];
                        for (let i = 0; i < lines.length; i++) {
                            if (/^STEP\..*Accuracy Test.*PASS/.test(lines[i])) {
                                blockStartIdxs.push(i);
                            }
                        }
                        let accuracyArr = [];
                        for (let b = 0; b < blockStartIdxs.length; b++) {
                            let start = blockStartIdxs[b] + 1;
                            let end = lines.length;
                            for (let j = start; j < lines.length; j++) {
                                if (/^-+/.test(lines[j]) || /^STEP\\./.test(lines[j])) {
                                    end = j;
                                    break;
                                }
                            }
                            // 查找最近的AC Input和Load Setup（在当前Accuracy Test之前）
                            let testCondition = '';
                            let closestAcInput = '';
                            let closestLoad = '';
                            
                            // 找到最近的AC Input（在当前Accuracy Test之前的最后一个）
                            for (let a = 0; a < acInputs.length; a++) {
                                if (acInputs[a].idx < blockStartIdxs[b]) {
                                    closestAcInput = acInputs[a].desc;
                                }
                            }
                            
                            // 找到最近的Load Setup（在当前Accuracy Test之前的最后一个）
                            for (let l = 0; l < loadSetups.length; l++) {
                                if (loadSetups[l].idx < blockStartIdxs[b]) {
                                    closestLoad = loadSetups[l].desc;
                                }
                            }
                            
                            // 组合测试条件：优先使用 AC Input + Load Setup 的组合
                            if (closestAcInput && closestLoad) {
                                testCondition = closestAcInput + ' ' + closestLoad;
                            } else if (closestLoad) {
                                testCondition = closestLoad;
                            } else if (closestAcInput) {
                                testCondition = closestAcInput;
                            } else {
                                // 如果没有找到AC Input和Load Setup，才使用Accuracy Test本身的Describe行
                                if (blockStartIdxs[b] + 1 < lines.length && /^Describe\s*:/.test(lines[blockStartIdxs[b] + 1])) {
                                    testCondition = lines[blockStartIdxs[b] + 1].replace(/^Describe\s*:\s*/, '').trim();
                                }
                            }
                            let accuracyData = {};
                            let foundParameters = [];
                            
                            // 动态识别所有参数
                            for (let k = start; k < end; k++) {
                                let line = lines[k];
                                
                                // 尝试匹配第一种格式: 参数名: 数值1, 数值2 ... [单位]
                                let m = line.match(/^\s*([A-Za-z0-9]+)\s*:\s*([\d\.]+)\s*,\s*([\d\.]+)\s+.*\[(.*?)\]/);
                                
                                // 如果第一种格式不匹配，尝试第二种格式: 参数名: 数值1, 数值2±百分比% [单位]
                                if (!m) {
                                    // 匹配格式如: Vmeter to Vset:  150.050, 150.000-0.03%   [0.5%]
                                    let m2 = line.match(/^\s*([A-Za-z\s]+to\s+[A-Za-z]+)\s*:\s*([\d\.]+)\s*,\s*([\d\.]+)([+-][\d\.]+%)\s+\[(.*?)\]/);
                                    if (m2) {
                                        let paramName = m2[1].trim().replace(/\s+/g, '_'); // 将空格替换为下划线
                                        let measuredValue = parseFloat(m2[2].trim());
                                        let referenceValue = parseFloat(m2[3].trim());
                                        let percentageStr = m2[4].trim(); // 如: -0.03% 或 +0.02%
                                        let unit = m2[5].trim();
                                        
                                        // 记录找到的参数名称
                                        if (!foundParameters.includes(paramName)) {
                                            foundParameters.push(paramName);
                                        }
                                        
                                        accuracyData[paramName + '_M'] = isNaN(measuredValue) ? '' : measuredValue;
                                        accuracyData[paramName + '_R'] = isNaN(referenceValue) ? '' : referenceValue;
                                        
                                        // 提取规格限值
                                        let specLimit = parseFloat(unit.replace('%', ''));
                                        if (!isNaN(specLimit)) {
                                            // 如果是百分比，转换为小数
                                            if (unit.includes('%')) {
                                                specLimit = specLimit / 100;
                                            }
                                            accuracyData[paramName + '_SpecLimit'] = specLimit;
                                        } else {
                                            accuracyData[paramName + '_SpecLimit'] = '';
                                        }
                                        
                                        // 直接使用文件中的百分比值
                                        accuracyData[paramName + '_Spec'] = percentageStr;
                                        continue;
                                    }
                                }
                                
                                if (m) {
                                    let paramName = m[1].trim();
                                    let a = parseFloat(m[2].trim());
                                    let b = parseFloat(m[3].trim());
                                    let unit = m[4].trim();
                                    
                                    // 记录找到的参数名称
                                    if (!foundParameters.includes(paramName)) {
                                        foundParameters.push(paramName);
                                    }
                                    
                                    accuracyData[paramName + '_M'] = isNaN(a) ? '' : a;
                                    accuracyData[paramName + '_R'] = isNaN(b) ? '' : b;
                                    
                                    // 提取规格限值
                                    let specLimit = parseFloat(unit.replace('%', ''));
                                    if (!isNaN(specLimit)) {
                                        // 如果是百分比，转换为小数
                                        if (unit.includes('%')) {
                                            specLimit = specLimit / 100;
                                        }
                                        accuracyData[paramName + '_SpecLimit'] = specLimit;
                                    } else {
                                        accuracyData[paramName + '_SpecLimit'] = '';
                                    }
                                    
                                    if (!isNaN(a) && !isNaN(b)) {
                                        if (unit.includes('%') && a !== 0) {
                                            let specVal = ((b - a) / a * 100).toFixed(2) + '%';
                                            accuracyData[paramName + '_Spec'] = specVal;
                                        } else {
                                            let specVal = (b - a).toFixed(2);
                                            accuracyData[paramName + '_Spec'] = specVal;
                                        }
                                    } else {
                                        accuracyData[paramName + '_Spec'] = '';
                                    }
                                }
                            }
                            accuracyArr.push({testCondition: testCondition, accuracyData: accuracyData, parameters: foundParameters});
                        }
                        if (!snMap[sn]) snMap[sn] = [];
                        accuracyArr.forEach(arr => {
                            let idx = snMap[sn].findIndex(item => item.testCondition === arr.testCondition);
                            if (idx >= 0) {
                                snMap[sn][idx] = arr;
                            } else {
                                snMap[sn].push(arr);
                            }
                        });
                        readCount++;
                        if (readCount === txtFiles.length) {
                            // 收集所有测试条件和参数
                            let allTestConditions = [];
                            let allParameters = [];
                            
                            Object.values(snMap).forEach(arr => {
                                arr.forEach(item => {
                                    if (!allTestConditions.includes(item.testCondition)) {
                                        allTestConditions.push(item.testCondition);
                                    }
                                    if (item.parameters) {
                                        item.parameters.forEach(param => {
                                            if (!allParameters.includes(param)) {
                                                allParameters.push(param);
                                            }
                                        });
                                    }
                                });
                            });
                            
                            // 过滤掉没有有效数据的参数 - 只保留至少在一个测试条件下有完整有效数据的参数
                            let validParameters = [];
                            allParameters.forEach(param => {
                                let hasValidDataInAnyCondition = false;
                                
                                // 检查每个测试条件下该参数是否有有效数据
                                for (let tc of allTestConditions) {
                                    let hasValidDataInThisCondition = false;
                                    let totalRecordsInCondition = 0;
                                    let validRecordsInCondition = 0;
                                    
                                    // 统计该测试条件下该参数的数据情况
                                    for (let sn of Object.keys(snMap)) {
                                        let found = snMap[sn].find(item => item.testCondition === tc);
                                        if (found) {
                                            totalRecordsInCondition++;
                                            let mValue = found.accuracyData[param + '_M'];
                                            let rValue = found.accuracyData[param + '_R'];
                                            let specValue = found.accuracyData[param + '_Spec'];
                                            
                                            // 检查该记录是否有有效数据（至少M、R、Spec中有一个有效）
                                            let hasValidRecord = false;
                                            if ((mValue && mValue !== '' && mValue !== '(未识别)' && mValue !== '-' && !isNaN(parseFloat(mValue))) ||
                                                (rValue && rValue !== '' && rValue !== '(未识别)' && rValue !== '-' && !isNaN(parseFloat(rValue))) ||
                                                (specValue && specValue !== '' && specValue !== '(未识别)' && specValue !== '-')) {
                                                hasValidRecord = true;
                                                validRecordsInCondition++;
                                            }
                                        }
                                    }
                                    
                                    // 如果该测试条件下有任何有效记录，则认为该参数在此条件下是有效的
                                    if (validRecordsInCondition > 0) {
                                        hasValidDataInThisCondition = true;
                                        hasValidDataInAnyCondition = true;
                                        break; // 找到一个有效条件就足够了
                                    }
                                }
                                
                                // 只有至少在一个测试条件下有有效数据的参数才添加到显示列表
                                if (hasValidDataInAnyCondition) {
                                    validParameters.push(param);
                                }
                            });
                            
                            // 使用过滤后的参数列表
                            allParameters = validParameters;
                            
                            // 保存modelName到全局变量，用于导出Excel文件名
                            window.currentModelName = modelName || 'Unknown';
                            
                            // 调试信息：显示过滤结果
                            console.log('原始参数:', Object.values(snMap).flatMap(arr => arr.flatMap(item => item.parameters || [])).filter((p, i, arr) => arr.indexOf(p) === i));
                            console.log('过滤后参数:', allParameters);
                            console.log('Model Name:', window.currentModelName);
                            
                            // 检查是否有有效的参数可以显示
                            if (allParameters.length === 0) {
                                cpkTableDiv.innerHTML = '<div style="text-align:center;padding:20px;color:#666;">未找到有效的Accuracy数据参数</div>';
                                return;
                            }
                            
                            let html = '<table class="data-table">';
                            html += '<tr>';
                            html += '<td class="header-cell">Test Condition</td>';
                            allTestConditions.forEach(tc => {
                                html += `<td colspan="${allParameters.length*3}" class="header-cell">${tc || '(无条件)'}</td>`;
                            });
                            html += '</tr>';
                            html += '<tr>';
                            html += '<td class="header-cell">Serial No</td>';
                            allTestConditions.forEach(tc => {
                                allParameters.forEach(function(param){
                                    html += `<td class="header-cell">${param}_M</td>`;
                                    html += `<td class="header-cell">${param}_R</td>`;
                                    html += `<td class="header-cell">${param}_Spec</td>`;
                                });
                            });
                            html += '</tr>';
                            
                            Object.keys(snMap).forEach(sn => {
                                html += '<tr>';
                                html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;\">${sn}</td>`;
                                allTestConditions.forEach(tc => {
                                    let found = snMap[sn].find(item => item.testCondition === tc);
                                    if (found) {
                                        allParameters.forEach(function(param){
                                            let mVal = found.accuracyData[param+'_M'];
                                            let rVal = found.accuracyData[param+'_R'];
                                            let specVal = found.accuracyData[param+'_Spec'];
                                            
                                            // 如果值为空、未识别或无效，显示为"-"
                                            mVal = (mVal && mVal !== '' && mVal !== '(未识别)') ? mVal : '-';
                                            rVal = (rVal && rVal !== '' && rVal !== '(未识别)') ? rVal : '-';
                                            specVal = (specVal && specVal !== '' && specVal !== '(未识别)') ? specVal : '-';
                                            
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;\">${mVal}</td>`;
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;\">${rVal}</td>`;
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;\">${specVal}</td>`;
                                        });
                                    } else {
                                        for(let i=0;i<allParameters.length*3;i++) html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;\">-</td>`;
                                    }
                                });
                                html += '</tr>';
                            });
                            
                            // 添加Unit行到最后
                            html += '<tr>';
                            html += '<td class="header-cell">Unit</td>';
                            allTestConditions.forEach(tc => {
                                allParameters.forEach(function(param){
                                    // 为每个参数确定单位
                                    let unit = '';
                                    let paramLower = param.toLowerCase();
                                    if (paramLower.includes('vin') || paramLower.includes('vout') || paramLower.includes('v') || paramLower.includes('vmeter')) {
                                        unit = 'V';
                                    } else if (paramLower.includes('iin') || paramLower.includes('iout') || paramLower.includes('i')) {
                                        unit = 'A';
                                    } else if (paramLower.includes('ein') || paramLower.includes('eout') || paramLower.includes('pin') || paramLower.includes('pout') || paramLower.includes('p')) {
                                        unit = 'W';
                                    } else if (paramLower.includes('thd')) {
                                        unit = '%';
                                    } else {
                                        unit = '';
                                    }
                                    
                                    html += `<td class="header-cell">${unit}</td>`; // M列单位
                                    html += `<td class="header-cell">${unit}</td>`; // R列单位
                                    html += `<td class="header-cell">%</td>`;       // Spec列单位固定为%
                                });
                            });
                            html += '</tr>';
                            
                            // 添加统计分析行
                            const analysisRows = [
                                'Lowest', 'Highest', 'Xbar', 'S', 'MAX_SPEC', 
                                'MIN_SPEC', 'Ca', 'Cp', 'CPL', 'CPU', 'CPK', 'Conclusion'
                            ];
                            
                            // 预先计算所有统计数据
                            let analysisData = {};
                            
                            // 为每个测试条件和参数计算统计值
                            allTestConditions.forEach(tc => {
                                allParameters.forEach(param => {
                                    let specValues = []; // 只收集Spec列的值
                                    
                                    // 收集所有该条件下该参数的Spec值
                                    Object.keys(snMap).forEach(sn => {
                                        let found = snMap[sn].find(item => item.testCondition === tc);
                                        if (found && found.accuracyData[param + '_Spec']) {
                                            let specVal = found.accuracyData[param + '_Spec'];
                                            if (typeof specVal === 'string') {
                                                // 如果是百分比形式，转换为小数形式
                                                if (specVal.includes('%')) {
                                                    specVal = parseFloat(specVal.replace('%', '')) / 100;
                                                } else {
                                                    specVal = parseFloat(specVal);
                                                }
                                            }
                                            if (!isNaN(specVal)) {
                                                specValues.push(specVal);
                                            }
                                        }
                                    });
                                    
                                    let key = tc + '_' + param;
                                    analysisData[key] = {};
                                    
                                    if (specValues.length > 0) {
                                        // 计算Lowest
                                        analysisData[key]['Lowest'] = Math.min(...specValues);
                                        
                                        // 计算Highest
                                        analysisData[key]['Highest'] = Math.max(...specValues);
                                        
                                        // 计算Xbar (平均值)
                                        analysisData[key]['Xbar'] = specValues.reduce((sum, val) => sum + val, 0) / specValues.length;
                                        
                                        // 计算S (总体标准差)
                                        let mean = analysisData[key]['Xbar'];
                                        let variance = specValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / specValues.length;
                                        analysisData[key]['S'] = Math.sqrt(variance);
                                        
                                        // 获取规格限值
                                        let specLimit = '';
                                        Object.keys(snMap).forEach(sn => {
                                            let found = snMap[sn].find(item => item.testCondition === tc);
                                            if (found && found.accuracyData[param + '_SpecLimit']) {
                                                specLimit = found.accuracyData[param + '_SpecLimit'];
                                            }
                                        });
                                        
                                        if (specLimit !== '') {
                                            analysisData[key]['MAX_SPEC'] = parseFloat(specLimit);
                                            analysisData[key]['MIN_SPEC'] = -parseFloat(specLimit);
                                            
                                            let maxSpec = analysisData[key]['MAX_SPEC'];
                                            let minSpec = analysisData[key]['MIN_SPEC'];
                                            let xbar = analysisData[key]['Xbar'];
                                            let s = analysisData[key]['S'];
                                            
                                            // 计算Ca
                                            if ((maxSpec - minSpec) !== 0) {
                                                analysisData[key]['Ca'] = Math.abs((xbar - (maxSpec + minSpec) / 2) / ((maxSpec - minSpec) / 2));
                                            }
                                            
                                            // 计算Cp
                                            if (s !== 0) {
                                                analysisData[key]['Cp'] = Math.abs((maxSpec - minSpec) / (6 * s));
                                            }
                                            
                                            // 计算CPL
                                            if (s !== 0) {
                                                analysisData[key]['CPL'] = (xbar - minSpec) / (3 * s);
                                            }
                                            
                                            // 计算CPU
                                            if (s !== 0) {
                                                analysisData[key]['CPU'] = (maxSpec - xbar) / (3 * s);
                                            }
                                            
                                            // 计算CPK (取CPL和CPU的最小值)
                                            if (analysisData[key]['CPL'] !== undefined && analysisData[key]['CPU'] !== undefined) {
                                                analysisData[key]['CPK'] = Math.min(analysisData[key]['CPL'], analysisData[key]['CPU']);
                                            } else if (analysisData[key]['CPL'] !== undefined) {
                                                analysisData[key]['CPK'] = analysisData[key]['CPL'];
                                            } else if (analysisData[key]['CPU'] !== undefined) {
                                                analysisData[key]['CPK'] = analysisData[key]['CPU'];
                                            }
                                            
                                            // 计算Conclusion
                                            if (analysisData[key]['CPK'] !== undefined) {
                                                analysisData[key]['Conclusion'] = analysisData[key]['CPK'] >= 1.33 ? 'PASS' : 'FAIL';
                                            }
                                        }
                                    }
                                });
                            });
                            
                            analysisRows.forEach(rowName => {
                                html += '<tr>';
                                html += `<td class="header-cell">${rowName}</td>`;
                                allTestConditions.forEach(tc => {
                                    allParameters.forEach(function(param){
                                        let key = tc + '_' + param;
                                        let value = '-';
                                        
                                        if (rowName === 'MAX_SPEC' || rowName === 'MIN_SPEC') {
                                            if (analysisData[key] && analysisData[key][rowName] !== undefined) {
                                                if (rowName === 'MAX_SPEC') {
                                                    value = '+' + analysisData[key][rowName].toFixed(4);
                                                } else {
                                                    value = analysisData[key][rowName].toFixed(4);
                                                }
                                            }
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;background-color:#ffe599;\">-</td>`; // M列 - 黄色背景
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;background-color:#ffe599;\">-</td>`; // R列 - 黄色背景
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;background-color:#ffe599;\">${value}</td>`; // Spec列 - 黄色背景
                                        } else if (rowName === 'Conclusion') {
                                            // Conclusion行特殊处理，添加颜色
                                            if (analysisData[key] && analysisData[key][rowName] !== undefined) {
                                                value = analysisData[key][rowName];
                                            }
                                            let backgroundColor = '';
                                            let textColor = '';
                                            if (value === 'PASS') {
                                                backgroundColor = '#38761d'; // 绿色背景
                                                textColor = '#fff'; // 白色文字
                                            } else if (value === 'FAIL') {
                                                backgroundColor = '#e06666'; // 红色背景
                                                textColor = '#fff'; // 白色文字
                                            }
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;\">-</td>`; // M列
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;\">-</td>`; // R列
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;background-color:${backgroundColor};color:${textColor};\">${value}</td>`; // Spec列
                                        } else {
                                            // 其他统计行只在Spec列显示计算值
                                            if (analysisData[key] && analysisData[key][rowName] !== undefined) {
                                                value = analysisData[key][rowName].toFixed(4);
                                            }
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;\">-</td>`; // M列
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;\">-</td>`; // R列
                                            html += `<td style=\"border:1px solid #ccc;padding:8px 12px;text-align:center;\">${value}</td>`; // Spec列
                                        }
                                    });
                                });
                                html += '</tr>';
                            });
                            html += '</table>';
                            cpkTableDiv.innerHTML = html;
                            
                            // 显示导出按钮
                            document.getElementById('exportCpkBtn').style.display = 'inline-block';
                        }
                    };
                    reader.readAsText(file);
                });
            };
            
            // 导出CPK按钮事件
            exportBtn.onclick = function() {
                const table = document.querySelector('#accuracyCpkTable table');
                if (!table) {
                    alert('請先執行 Accuracy CPK 生成數據');
                    return;
                }
                
                // 创建工作簿
                const wb = XLSX.utils.book_new();
                
                // 转换表格为工作表数据
                const ws_data = [];
                const rows = table.querySelectorAll('tr');
                
                // 处理表头行
                rows.forEach((row, rowIndex) => {
                    const rowData = [];
                    const cells = row.querySelectorAll('td, th');
                    cells.forEach(cell => {
                        const colspan = parseInt(cell.getAttribute('colspan')) || 1;
                        const cellValue = cell.textContent.trim();
                        
                        // 添加单元格数据
                        rowData.push(cellValue);
                        
                        // 处理合并单元格
                        for (let i = 1; i < colspan; i++) {
                            rowData.push(''); // 空单元格用于合并
                        }
                    });
                    ws_data.push(rowData);
                });
                
                // 创建工作表
                const ws = XLSX.utils.aoa_to_sheet(ws_data);
                
                // 添加公式到Spec列
                if (ws_data.length > 2) {
                    const headerRow = ws_data[1]; // 第二行是详细的列标题
                    
                    // 找到各个统计行的索引
                    let unitRowIdx = -1, lowestRowIdx = -1, highestRowIdx = -1, xbarRowIdx = -1, sRowIdx = -1;
                    let maxSpecRowIdx = -1, minSpecRowIdx = -1, caRowIdx = -1, cpRowIdx = -1;
                    let cplRowIdx = -1, cpuRowIdx = -1, cpkRowIdx = -1, conclusionRowIdx = -1;
                    
                    for (let i = 0; i < ws_data.length; i++) {
                        switch(ws_data[i][0]) {
                            case 'Unit': unitRowIdx = i; break;
                            case 'Lowest': lowestRowIdx = i; break;
                            case 'Highest': highestRowIdx = i; break;
                            case 'Xbar': xbarRowIdx = i; break;
                            case 'S': sRowIdx = i; break;
                            case 'MAX_SPEC': maxSpecRowIdx = i; break;
                            case 'MIN_SPEC': minSpecRowIdx = i; break;
                            case 'Ca': caRowIdx = i; break;
                            case 'Cp': cpRowIdx = i; break;
                            case 'CPL': cplRowIdx = i; break;
                            case 'CPU': cpuRowIdx = i; break;
                            case 'CPK': cpkRowIdx = i; break;
                            case 'Conclusion': conclusionRowIdx = i; break;
                        }
                    }
                    
                    for (let rowIdx = 2; rowIdx < ws_data.length; rowIdx++) {
                        let colIdx = 1; // 从第二列开始（跳过Serial No列）
                        
                        // 遍历每个测试条件组
                        for (let groupIdx = 0; colIdx < headerRow.length; groupIdx++) {
                            // 计算当前组的参数数量
                            let paramCount = 0;
                            let startColIdx = colIdx;
                            
                            // 计算参数数量（每个参数3列：M, R, Spec）
                            while (colIdx < headerRow.length && (colIdx - startColIdx) % 3 !== 0 || colIdx === startColIdx) {
                                if ((colIdx - startColIdx) % 3 === 0 && colIdx > startColIdx) {
                                    break;
                                }
                                if ((colIdx - startColIdx + 1) % 3 === 0) {
                                    paramCount++;
                                }
                                colIdx++;
                            }
                            colIdx = startColIdx; // 重置到组开始位置
                            
                            // 处理当前组的每个参数
                            for (let paramIdx = 0; paramIdx < paramCount && colIdx < headerRow.length; paramIdx++) {
                                const mCol = colIdx;     // M列
                                const rCol = colIdx + 1; // R列  
                                const specCol = colIdx + 2; // Spec列
                                
                                if (specCol < headerRow.length) {
                                    const mCellRef = XLSX.utils.encode_cell({r: rowIdx, c: mCol});
                                    const rCellRef = XLSX.utils.encode_cell({r: rowIdx, c: rCol});
                                    const specCellRef = XLSX.utils.encode_cell({r: rowIdx, c: specCol});
                                    
                                    // 获取当前Spec列的值来判断是百分比还是绝对值
                                    const currentSpecValue = ws_data[rowIdx][specCol];
                                    
                                    if (currentSpecValue && currentSpecValue !== '-' && currentSpecValue !== '(未识别)') {
                                        // 检查M和R列是否有有效数值
                                        const mValue = parseFloat(ws_data[rowIdx][mCol]);
                                        const rValue = parseFloat(ws_data[rowIdx][rCol]);
                                        
                                        if (!isNaN(mValue) && !isNaN(rValue) && mValue !== 0) {
                                            let formula = '';
                                            
                                            if (currentSpecValue.includes('%')) {
                                                // 百分比公式: (R-M)/M，Excel会自动转换为百分比显示
                                                formula = `(${rCellRef}-${mCellRef})/${mCellRef}`;
                                                // 设置单元格格式为百分比
                                                ws[specCellRef] = { f: formula, t: 'n', z: '0.00%' };
                                            } else {
                                                // 数值公式: (R-M)/M
                                                formula = `(${rCellRef}-${mCellRef})/${mCellRef}`;
                                                // 设置单元格格式为数值
                                                ws[specCellRef] = { f: formula, t: 'n', z: '0.0000' };
                                            }
                                        }
                                    }
                                    
                                    // 为统计分析行添加公式（只在Spec列）
                                    if (rowIdx === lowestRowIdx && lowestRowIdx !== -1 && unitRowIdx !== -1) {
                                        // Lowest: MIN函数
                                        const dataRange = `${XLSX.utils.encode_cell({r: 2, c: specCol})}:${XLSX.utils.encode_cell({r: unitRowIdx - 1, c: specCol})}`;
                                        ws[specCellRef] = { f: `MIN(${dataRange})`, t: 'n', z: '0.0000' };
                                    } else if (rowIdx === highestRowIdx && highestRowIdx !== -1 && unitRowIdx !== -1) {
                                        // Highest: MAX函数
                                        const dataRange = `${XLSX.utils.encode_cell({r: 2, c: specCol})}:${XLSX.utils.encode_cell({r: unitRowIdx - 1, c: specCol})}`;
                                        ws[specCellRef] = { f: `MAX(${dataRange})`, t: 'n', z: '0.0000' };
                                    } else if (rowIdx === xbarRowIdx && xbarRowIdx !== -1 && unitRowIdx !== -1) {
                                        // Xbar: AVERAGE函数
                                        const dataRange = `${XLSX.utils.encode_cell({r: 2, c: specCol})}:${XLSX.utils.encode_cell({r: unitRowIdx - 1, c: specCol})}`;
                                        ws[specCellRef] = { f: `AVERAGE(${dataRange})`, t: 'n', z: '0.0000' };
                                    } else if (rowIdx === sRowIdx && sRowIdx !== -1 && unitRowIdx !== -1) {
                                        // S: STDEV函数（标准差）
                                        const dataRange = `${XLSX.utils.encode_cell({r: 2, c: specCol})}:${XLSX.utils.encode_cell({r: unitRowIdx - 1, c: specCol})}`;
                                        ws[specCellRef] = { f: `STDEV(${dataRange})`, t: 'n', z: '0.0000' };
                                    } else if (rowIdx === caRowIdx && caRowIdx !== -1 && xbarRowIdx !== -1 && maxSpecRowIdx !== -1 && minSpecRowIdx !== -1) {
                                        // Ca: ABS((Xbar-(MAX_SPEC+MIN_SPEC)/2)/((MAX_SPEC-MIN_SPEC)/2))
                                        const xbarCell = XLSX.utils.encode_cell({r: xbarRowIdx, c: specCol});
                                        const maxSpecCell = XLSX.utils.encode_cell({r: maxSpecRowIdx, c: specCol});
                                        const minSpecCell = XLSX.utils.encode_cell({r: minSpecRowIdx, c: specCol});
                                        ws[specCellRef] = { f: `ABS((${xbarCell}-(${maxSpecCell}+${minSpecCell})/2)/((${maxSpecCell}-${minSpecCell})/2))`, t: 'n', z: '0.0000' };
                                    } else if (rowIdx === cpRowIdx && cpRowIdx !== -1 && sRowIdx !== -1 && maxSpecRowIdx !== -1 && minSpecRowIdx !== -1) {
                                        // Cp: ABS((MAX_SPEC-MIN_SPEC)/(6*S))
                                        const sCell = XLSX.utils.encode_cell({r: sRowIdx, c: specCol});
                                        const maxSpecCell = XLSX.utils.encode_cell({r: maxSpecRowIdx, c: specCol});
                                        const minSpecCell = XLSX.utils.encode_cell({r: minSpecRowIdx, c: specCol});
                                        ws[specCellRef] = { f: `ABS((${maxSpecCell}-${minSpecCell})/(6*${sCell}))`, t: 'n', z: '0.0000' };
                                    } else if (rowIdx === cplRowIdx && cplRowIdx !== -1 && xbarRowIdx !== -1 && sRowIdx !== -1 && minSpecRowIdx !== -1) {
                                        // CPL: (Xbar-MIN_SPEC)/(3*S)
                                        const xbarCell = XLSX.utils.encode_cell({r: xbarRowIdx, c: specCol});
                                        const sCell = XLSX.utils.encode_cell({r: sRowIdx, c: specCol});
                                        const minSpecCell = XLSX.utils.encode_cell({r: minSpecRowIdx, c: specCol});
                                        ws[specCellRef] = { f: `(${xbarCell}-${minSpecCell})/(3*${sCell})`, t: 'n', z: '0.0000' };
                                    } else if (rowIdx === cpuRowIdx && cpuRowIdx !== -1 && xbarRowIdx !== -1 && sRowIdx !== -1 && maxSpecRowIdx !== -1) {
                                        // CPU: (MAX_SPEC-Xbar)/(3*S)
                                        const xbarCell = XLSX.utils.encode_cell({r: xbarRowIdx, c: specCol});
                                        const sCell = XLSX.utils.encode_cell({r: sRowIdx, c: specCol});
                                        const maxSpecCell = XLSX.utils.encode_cell({r: maxSpecRowIdx, c: specCol});
                                        ws[specCellRef] = { f: `(${maxSpecCell}-${xbarCell})/(3*${sCell})`, t: 'n', z: '0.0000' };
                                    } else if (rowIdx === cpkRowIdx && cpkRowIdx !== -1 && cplRowIdx !== -1 && cpuRowIdx !== -1) {
                                        // CPK: MIN(CPL,CPU)
                                        const cplCell = XLSX.utils.encode_cell({r: cplRowIdx, c: specCol});
                                        const cpuCell = XLSX.utils.encode_cell({r: cpuRowIdx, c: specCol});
                                        ws[specCellRef] = { f: `MIN(${cplCell},${cpuCell})`, t: 'n', z: '0.0000' };
                                    } else if (rowIdx === conclusionRowIdx && conclusionRowIdx !== -1 && cpkRowIdx !== -1) {
                                        // Conclusion: IF(CPK>=1.33,"PASS","FAIL")
                                        const cpkCell = XLSX.utils.encode_cell({r: cpkRowIdx, c: specCol});
                                        ws[specCellRef] = { f: `IF(${cpkCell}>=1.33,"PASS","FAIL")`, t: 's' };
                                    }
                                }
                                
                                colIdx += 3; // 移动到下一组（M, R, Spec）
                            }
                        }
                    }
                }
                
                // 在处理合并单元格前，重新设置所有样式（确保样式不被公式覆盖）
                const range = XLSX.utils.decode_range(ws['!ref']);
                
                // 为所有单元格设置基本样式（居中对齐和边框）
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cell_address = XLSX.utils.encode_cell({r: R, c: C});
                        if (ws[cell_address]) {
                            // 保留现有样式，只添加缺失的样式
                            if (!ws[cell_address].s) ws[cell_address].s = {};
                            
                            // 设置居中对齐
                            ws[cell_address].s.alignment = { horizontal: 'center', vertical: 'center' };
                            
                            // 设置边框
                            ws[cell_address].s.border = {
                                top: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                bottom: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                left: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                right: {style: 'thin', color: {rgb: 'CCCCCC'}}
                            };
                        }
                    }
                }
                
                // 重新为表头行设置背景色和字体样式
                const headerRows = [0, 1]; // 第一行和第二行是表头
                headerRows.forEach(rowIdx => {
                    if (rowIdx <= range.e.r) {
                        for (let C = range.s.c; C <= range.e.c; ++C) {
                            const cell_address = XLSX.utils.encode_cell({r: rowIdx, c: C});
                            if (ws[cell_address]) {
                                if (!ws[cell_address].s) ws[cell_address].s = {};
                                ws[cell_address].s.fill = {
                                    patternType: 'solid',
                                    fgColor: {rgb: 'F5F5F7'}
                                };
                                ws[cell_address].s.font = {bold: true};
                                // 重新设置居中对齐和边框
                                ws[cell_address].s.alignment = { horizontal: 'center', vertical: 'center' };
                                ws[cell_address].s.border = {
                                    top: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    bottom: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    left: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    right: {style: 'thin', color: {rgb: 'CCCCCC'}}
                                };
                            }
                        }
                    }
                });
                
                // 重新为Unit行设置背景色
                let finalUnitRowIdx = -1;
                for (let i = 0; i < ws_data.length; i++) {
                    if (ws_data[i][0] === 'Unit') {
                        finalUnitRowIdx = i;
                        break;
                    }
                }
                if (finalUnitRowIdx !== -1) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cell_address = XLSX.utils.encode_cell({r: finalUnitRowIdx, c: C});
                        if (ws[cell_address]) {
                            if (!ws[cell_address].s) ws[cell_address].s = {};
                            ws[cell_address].s.fill = {
                                patternType: 'solid',
                                fgColor: {rgb: 'F5F5F7'}
                            };
                            ws[cell_address].s.font = {bold: true};
                            // 重新设置居中对齐和边框
                            ws[cell_address].s.alignment = { horizontal: 'center', vertical: 'center' };
                            ws[cell_address].s.border = {
                                top: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                bottom: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                left: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                right: {style: 'thin', color: {rgb: 'CCCCCC'}}
                            };
                        }
                    }
                }
                
                // 重新为MAX_SPEC和MIN_SPEC行设置黄色背景
                const finalSpecRowNames = ['MAX_SPEC', 'MIN_SPEC'];
                finalSpecRowNames.forEach(specRowName => {
                    let specRowIdx = -1;
                    for (let i = 0; i < ws_data.length; i++) {
                        if (ws_data[i][0] === specRowName) {
                            specRowIdx = i;
                            break;
                        }
                    }
                    if (specRowIdx !== -1) {
                        for (let C = range.s.c; C <= range.e.c; ++C) {
                            const cell_address = XLSX.utils.encode_cell({r: specRowIdx, c: C});
                            if (ws[cell_address]) {
                                if (!ws[cell_address].s) ws[cell_address].s = {};
                                ws[cell_address].s.fill = {
                                    patternType: 'solid',
                                    fgColor: {rgb: 'FFE599'}
                                };
                                // 重新设置居中对齐和边框
                                ws[cell_address].s.alignment = { horizontal: 'center', vertical: 'center' };
                                ws[cell_address].s.border = {
                                    top: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    bottom: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    left: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    right: {style: 'thin', color: {rgb: 'CCCCCC'}}
                                };
                            }
                        }
                    }
                });
                
                // 重新为Conclusion行设置颜色
                let finalConclusionRowIdx = -1;
                for (let i = 0; i < ws_data.length; i++) {
                    if (ws_data[i][0] === 'Conclusion') {
                        finalConclusionRowIdx = i;
                        break;
                    }
                }
                if (finalConclusionRowIdx !== -1) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cell_address = XLSX.utils.encode_cell({r: finalConclusionRowIdx, c: C});
                        if (ws[cell_address]) {
                            const cellValue = ws_data[finalConclusionRowIdx][C];
                            if (cellValue === 'PASS') {
                                if (!ws[cell_address].s) ws[cell_address].s = {};
                                ws[cell_address].s.fill = {
                                    patternType: 'solid',
                                    fgColor: {rgb: '38761D'}
                                };
                                ws[cell_address].s.font = {color: {rgb: 'FFFFFF'}, bold: true};
                                // 重新设置居中对齐和边框
                                ws[cell_address].s.alignment = { horizontal: 'center', vertical: 'center' };
                                ws[cell_address].s.border = {
                                    top: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    bottom: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    left: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    right: {style: 'thin', color: {rgb: 'CCCCCC'}}
                                };
                            } else if (cellValue === 'FAIL') {
                                if (!ws[cell_address].s) ws[cell_address].s = {};
                                ws[cell_address].s.fill = {
                                    patternType: 'solid',
                                    fgColor: {rgb: 'E06666'}
                                };
                                ws[cell_address].s.font = {color: {rgb: 'FFFFFF'}, bold: true};
                                // 重新设置居中对齐和边框
                                ws[cell_address].s.alignment = { horizontal: 'center', vertical: 'center' };
                                ws[cell_address].s.border = {
                                    top: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    bottom: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    left: {style: 'thin', color: {rgb: 'CCCCCC'}},
                                    right: {style: 'thin', color: {rgb: 'CCCCCC'}}
                                };
                            }
                        }
                    }
                }
                
                // 设置列宽
                const colWidths = [];
                if (ws_data.length > 0) {
                    for (let i = 0; i < ws_data[0].length; i++) {
                        colWidths.push({ wch: 12 });
                    }
                    ws['!cols'] = colWidths;
                }
                
                // 处理合并单元格
                const merges = [];
                rows.forEach((row, rowIndex) => {
                    let colIndex = 0;
                    const cells = row.querySelectorAll('td, th');
                    cells.forEach(cell => {
                        const colspan = parseInt(cell.getAttribute('colspan')) || 1;
                        if (colspan > 1) {
                            merges.push({
                                s: { r: rowIndex, c: colIndex },
                                e: { r: rowIndex, c: colIndex + colspan - 1 }
                            });
                        }
                        colIndex += colspan;
                    });
                });
                ws['!merges'] = merges;
                
                // 添加工作表到工作簿
                XLSX.utils.book_append_sheet(wb, ws, 'Accuracy CPK Data');
                
                // 生成文件名（Model Name + Accuracy CPK + 时间）
                const now = new Date();
                const timeStr = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}`;
                const modelName = window.currentModelName || 'Unknown';
                const fileName = `${modelName}_Accuracy_CPK_${timeStr}.xlsx`;
                
                // 导出文件
                XLSX.writeFile(wb, fileName);
            };

            // 语言切换功能
            const langSelect = document.getElementById('langSelect');
            langSelect.addEventListener('change', function() {
                const selectedLang = this.value;
                updateLanguage(selectedLang);
            });

            // 更新语言函数
            function updateLanguage(lang) {
                const t = translations[lang];
                
                // 更新页面标题
                document.querySelector('h1').innerHTML = `<i class="fa-solid fa-bullseye" style="margin-right: 16px;"></i>${t.title}`;
                
                // 更新按钮文本
                document.getElementById('chooseFolderBtn').innerHTML = `<i class="fa-solid fa-folder-open" style="margin-right: 8px;"></i> ${t.uploadFolder}`;
                document.getElementById('execAccuracyCpkBtn').innerHTML = t.executeAccuracyCpk;
                document.getElementById('exportCpkBtn').innerHTML = `<i class="fa-solid fa-download" style="margin-right: 8px;"></i>${t.exportCpkExcel}`;
                
                // 更新帮助提示
                document.querySelector('.help-icon').setAttribute('title', t.help);
                
                // 更新AI聊天相关
                document.getElementById('toggleChatBtn').innerHTML = `<i class="fa-solid fa-comments"></i> ${t.showAiChat}`;
                document.getElementById('ai-chat-drag').innerHTML = `<i class="fa-solid fa-robot"></i> ${t.aiChat}`;
                document.getElementById('ai-chat-input').setAttribute('placeholder', t.inputPlaceholder);
                document.getElementById('ai-chat-send').innerHTML = `<i class="fa-solid fa-paper-plane"></i> ${t.send}`;
            }

            // AI聊天功能
            let isChatVisible = false;
            let chatHistory = [];

            const toggleChatBtn = document.getElementById('toggleChatBtn');
            const chatBox = document.getElementById('ai-chat-box');
            const chatInput = document.getElementById('ai-chat-input');
            const chatSend = document.getElementById('ai-chat-send');
            const chatHistoryDiv = document.getElementById('ai-chat-history');

            // 切换聊天框显示
            toggleChatBtn.addEventListener('click', function() {
                isChatVisible = !isChatVisible;
                if (isChatVisible) {
                    chatBox.style.display = 'block';
                    const currentLang = langSelect.value;
                    const t = translations[currentLang];
                    this.innerHTML = `<i class="fa-solid fa-comments"></i> ${t.hideAiChat}`;
                } else {
                    chatBox.style.display = 'none';
                    const currentLang = langSelect.value;
                    const t = translations[currentLang];
                    this.innerHTML = `<i class="fa-solid fa-comments"></i> ${t.showAiChat}`;
                }
            });

            // 发送消息
            function sendMessage() {
                const message = chatInput.value.trim();
                if (!message) return;

                // 添加用户消息
                addMessageToHistory('user', message);
                chatInput.value = '';

                // 模拟AI回复
                setTimeout(() => {
                    const aiResponse = generateAIResponse(message);
                    addMessageToHistory('ai', aiResponse);
                }, 1000);
            }

            // 添加消息到历史记录
            function addMessageToHistory(sender, message) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${sender}-message`;
                messageDiv.textContent = message;
                chatHistoryDiv.appendChild(messageDiv);
                chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
            }

            // 生成AI回复（模拟）
            function generateAIResponse(userMessage) {
                const responses = {
                    'zh-TW': [
                        '關於Accuracy CPK分析，請確保您已上傳包含測試數據的txt文件。',
                        '您可以查看生成的表格來了解各參數的CPK值和統計結果。',
                        '如果需要導出結果，請點擊"導出 CPK Excel"按鈕。',
                        '請檢查測試條件是否正確識別，每個條件應該包含AC Input和Load Setup信息。'
                    ],
                    'en': [
                        'For Accuracy CPK analysis, please ensure you have uploaded txt files containing test data.',
                        'You can view the generated table to understand CPK values and statistical results for each parameter.',
                        'If you need to export results, please click the "Export CPK Excel" button.',
                        'Please check if test conditions are correctly identified, each condition should contain AC Input and Load Setup information.'
                    ],
                    'vi': [
                        'Để phân tích Accuracy CPK, vui lòng đảm bảo bạn đã tải lên các tệp txt chứa dữ liệu thử nghiệm.',
                        'Bạn có thể xem bảng được tạo để hiểu các giá trị CPK và kết quả thống kê cho từng tham số.',
                        'Nếu bạn cần xuất kết quả, vui lòng nhấp vào nút "Xuất CPK Excel".',
                        'Vui lòng kiểm tra xem các điều kiện thử nghiệm có được xác định chính xác không, mỗi điều kiện nên chứa thông tin AC Input và Load Setup.'
                    ]
                };
                
                const currentLang = langSelect.value;
                const langResponses = responses[currentLang] || responses['zh-TW'];
                return langResponses[Math.floor(Math.random() * langResponses.length)];
            }

            // 监听发送按钮和回车键
            chatSend.addEventListener('click', sendMessage);
            chatInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            // 拖拽功能
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            document.getElementById('ai-chat-drag').addEventListener('mousedown', function(e) {
                isDragging = true;
                const rect = chatBox.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    chatBox.style.left = (e.clientX - dragOffset.x) + 'px';
                    chatBox.style.top = (e.clientY - dragOffset.y) + 'px';
                    chatBox.style.right = 'auto';
                }
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
            });
        });
        </script>
      </div>
    </div>
    </div>
</body>
</html>
